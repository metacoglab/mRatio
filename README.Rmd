---
output: github_document
bibliography: vignettes/citations.bib
link-citations: true
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# mRatio

<!-- badges: start -->
  [![R-CMD-check](https://github.com/metacoglab/mRatio/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/metacoglab/mRatio/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

The mRatio package is designed to fit the meta-dâ€™ model for confidence
ratings [@maniscalco2012; @maniscalco2014]. Like the [Hmeta-d toolbox](https://github.com/metacoglab/HMeta-d) [@fleming2017], the mRatio package uses a Bayesian modeling approach. The mRatio package builds on the Hmeta-d toolbox through implementation as a custom family in the [brms](https://paulbuerkner.com/brms/) package, which itself provides a friendly interface to the probabilistic programming language [Stan](https://mc-stan.org). 

This provides major benefits:

  - Model designs can be specified as simple `R` formulas
  - Support for complex model designs (e.g., multilevel models, distributional models)
  - Interfaces to other packages surrounding `brms` (e.g., `tidybayes`, `ggdist`, `bayesplot`, `loo`, `posterior`, `bridgesampling`)
  - Computation of model-implied quantities (e.g., mean confidence, type 1 and type 2 receiver operating characteristic curves, metacognitive bias)
  - Increased sampling efficiency and better convergence diagnostics



## Installation

You can install the development version of mRatio from [GitHub](https://github.com/metacoglab/mRatio) with:

``` {r install, eval=FALSE}
# install.packages("pak")
pak::pak("metacoglab/mRatio")
```

## Get started
Let's say you have some data from a binary decision task with ordinal confidence ratings:

```{r data, echo=FALSE, message=FALSE, warning=FALSE}
library(mRatio)
library(dplyr)
d <- sim_metad(N_trials=1000) |>
  ungroup() |>
  select(trial:confidence) |>
  slice_sample(prop=1) |>
  mutate(trial=row_number())
d
```

You can fit an intercepts-only meta-d' model using `fit_metad`:

```{r example, results=FALSE, warning=FALSE, message=FALSE}
library(mRatio)

m <- fit_metad(N ~ 1, data=d, file="vignettes/models/readme1.rds")
```

```{r summary, echo=FALSE, warning=FALSE, message=FALSE}
m
```


Now let's say you have a more complicated design, such as a within-participants manipulation:

```{r data2, echo=FALSE}
d <- sim_metad_participant_condition(N_participants=25) |>
  group_by(participant, condition) |>
  select(participant:confidence) |>
  slice_sample(prop=1) |>
  mutate(trial=row_number())
d
```

To account for the repeated measures in this design, you can simply adjust the formula to include participant-level effects:

```{r example2, results=FALSE, warning=FALSE, message=FALSE}
m <- fit_metad(
  bf(N ~ condition + (condition | participant),
    dprime + c + 
      metac2zero1diff + metac2zero2diff + metac2zero3diff + 
      metac2one1diff + metac2one2diff + metac2one3diff ~
      condition + (condition | participant)), 
  data=d, init="0", file="vignettes/models/readme2.rds",
  prior = prior(normal(0, 1)) +
    prior(normal(0, 1), dpar = dprime) +
    prior(normal(0, 1), dpar = c) +
    prior(normal(0, 1), dpar = metac2zero1diff) +
    prior(normal(0, 1), dpar = metac2zero2diff) +
    prior(normal(0, 1), dpar = metac2zero3diff) +
    prior(normal(0, 1), dpar = metac2one1diff) +
    prior(normal(0, 1), dpar = metac2one2diff) +
    prior(normal(0, 1), dpar = metac2one3diff))
```

```{r summary2, echo=FALSE, warning=FALSE, message=FALSE}
m
```

## References
